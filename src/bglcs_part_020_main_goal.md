# The Main Goal

> _"Education is not preparation for life; education is life itself."_
>
> —John "Not The Decimal System One" Dewey

> _"The illiterate of the 21st century will not be those who cannot read
> and write, but those who cannot learn, unlearn, and relearn."_
>
> —Alvin Toffler

What are we learning in school? How to be a Flutter developer? How to be
a React developer? How to be a Rust developer? How to be a JavaScript
developer? How to be a C++ developer? How to be a C developer? How to be
a Pascal developer? How to be a LISP developer? How to be a FORTRAN
developer? How to be a COBOL developer?

See what I did there? Besides ask a lot of questions?

Yes, you might be wanting to go to school so you can work on web
development or embedded systems in the latest and greatest languages.
And maybe if you're lucky, you'll do some of that in school.

But here's the problem:

1. There are too many technologies to cover in four years.
2. All that stuff is going to be obsolete soon, anyway. See how I added
   [flw[COBOL|COBOL]] to the list[^7152]?

[^7152]: Joke's on me. There are still tons of COBOL jobs out there.

So what can you as a student do? There's no way you're covering it all.

This is where the main goal comes into play. Your job as a student is to
do one thing:

***Learn how to solve any programming problem.***

Even if you've never seen the problem or technology in your entire life.

That's the whole goal.

Importantly, it's not to learn to be an iPhone developer or an Android
developer or a Go developer. All that stuff is covered by the main goal.
You might not learn Go programming in school, but you'll _learn how to
learn Go programming on your own_.

***Learn how to solve any programming problem.***

That's it. Everything else is window dressing.

Being able to learn things on your own is a **required** skill when it
comes to software development. It's **really** unlikely that your first
job will solely use technologies you've used in school. And, in fact,
recently-graduated students might be surprised to find out that **none**
of the technologies they've used at school are present in their first
gig.

So why on Earth did we just spend four years learning all this crap
about operating systems and assembly language and algorithmic analysis
and—?

*EERRRNT!* You didn't just spend four years doing that. You just spent
four years *learning to solve any programming problem*.

And think about it. How would you teach people to solve *any* problem?
Well, you can't exhaustively teach them [flw[all zillion programming
languages|List_of_programming_languages]], frameworks, and techniques.
So that's off the table. And whichever ones you do pick might or might
not be used for a particular person's job.

So we have to get more fundamental. We have to practice solving problems
so many times that we develop and enhance our problem-solving skills.
Because you're going to be faced with problems in an interview or at
work that are completely unfamiliar. You won't be able to draw on any
specific languages or algorithms you've learned. The one thing you will
be able to use is your problem-solving skill.

Finally, there's a bit of a corollary here: when you're learning to do
something you'll never use at work, *don't cheat*. The goal isn't to
learn how to delete the head of a linked list. The goal is to practice
solving programming problems! And just looking up the answer deprives
you of that practice. Cheat your way through all the assignments at
school and you'll never develop the one fundamental skill of software
developers: being able to solve any programming problem.

