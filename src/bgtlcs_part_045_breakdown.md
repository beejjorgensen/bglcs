# Breaking Down Problems

> _"There's games beyond the game."_
>
> â€”Stringer Bell, _The Wire_

If the problem solving steps (_Understand_, _Plan_, _Code_, _Reflect_)
had a sequel, this chapter would be it.

Those steps really do get you through every problem, but it turns out
those problems exist as fractal problems within problems within
problems.

As an example, maybe you want to build a table. That's the entire
problem:

* Build a table

Well, that might not be enough if you haven't built a lot of
tables. So you break down the problem into dependent subproblems.

* Build a table
  * Attach legs to tabletop
    * Build tabletop
    * Build legs

And maybe that's not enough. How do you make legs? How do you make the
tabletop?

* Build a table
  * Attach legs to tabletop
    * Build tabletop
      * Sand table surface
        * Glue trim to top
          * Cut main top
            * Learn to use a table saw
          * Cut trim
    * Build legs
      * Cut legs
      * Turn legs on lathe
        * Learn to use a lathe

And so on. *We keep breaking down the problem until we get the step
small enough that we know we can accomplish it.*

When you're first starting out, the steps might be single lines of code
that you eventually boil the problem down into. Experienced devs often
don't have to break it down that far because they are well-versed in the
substeps.

For example, a carpenter with modest experience might only need to break
down building a table into our second set of steps, above, and not go
into such detail.

Like everything, breaking down a problem is a skill, and you get better
with practice.

When breaking down problems, complete the probing question we talked
about earlier, "This problem would be easy if the input data were in
_this_ form." That's a hint that you should break out a subproblem that
converts the data into that form.

And once you have a subproblem, pretend that it's the entire problem,
just for a bit. Focus myopically on it and see if you can solve it. If
not, ask yourself what would make it easy to solve, and break that out
into a subproblem.

Repeat.

The more you practice breaking down problems and coding solutions, the
better you'll get at it. Soon you won't have to break down problems
quite as far as you needed to before, and, like an expert, you'll start
recognizing patterns you can reuse.

However, it's not always obvious _how_ to break down a problem. One
technique is to imagine a physical manifestation of the thing you're
trying to code. (For example, you're writing a sort? Imagine a bunch of
alphabet blocks on a table and you have to sort them.)

TODO

## Pseudocode

TODO

## Proof of Concept

TODO

